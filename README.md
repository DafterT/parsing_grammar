# Практическое задание 3

## О работе
- Курс: «Языки программирования», практическое задание №3 (вариант 2).
- Студент: Д. Л. Симоновский, группа P4119. 
- Руководитель: Ю. Д. Кореньков.
- Отчёт: `report/ЯП_3_лаба_Р4119_Симоновский.pdf`.

## Состав репозитория
- Грамматика tree-sitter: `tree-sitter/grammar.js`, исходники парсера `tree-sitter/src/parser.c`, готовая сборка `tree-sitter/var2.dll`.
- Python-пакет для трансляции: `python/` (`main.py`, `file_parser_to_graph.py`, `graph_parser.py`, `tree_parser.py`, `get_parse_tree.py`, `ast_generator.py`, `generate_asm.py`, `type_checker.py`, `types_generator.py`).
- Примеры входных программ: `examples/*` (файлы без расширения).
- Скрипт сборки и выполнения: `architecture/build.ps1`.
- Отчёт в `report/`.

## Требования
- Python 3.10+.
- Node.js + `tree-sitter` CLI (для сборки из грамматики): `npm i -g tree-sitter-cli`.
- Graphviz установлен в системе (для рендеринга `.svg`) и Python-пакет `graphviz`.
- PowerShell (для запуска скрипта сборки).

## Установка Python-зависимостей
Рекомендуется виртуальное окружение:
```
python -m venv .venv
.venv\Scripts\activate      # PowerShell/cmd
pip install -r requirements.txt
```

## Сборка парсера tree-sitter вручную
CLI-команды исполняются в папке `tree-sitter/`:
```
tree-sitter g       # сгенерировать src/parser.c
tree-sitter b       # собрать shared-библиотеку (Windows DLL)
```
Готовая библиотека появится как `parser.dll` в папке `tree-sitter/`.

## Запуск транслятора

### Шаг 1: Генерация ассемблерного кода
Скрипт `python/main.py` выполняет полный цикл трансляции:
- Парсит исходный код
- Строит деревья разбора и CFG каждой функции
- Выполняет проверку типов
- Генерирует ассемблерный код

**Формат команды:**
```
python .\python\main.py <путь_к_dll> --lib var2 <входной_файл> [<входной_файл2> ...] <выходная_директория>
```

**Пример:**
```
python .\python\main.py .\tree-sitter\parser.dll --lib var2 .\examples\12_recursion out
```

**Аргументы:**
- Первый аргумент: путь к скомпилированной tree-sitter библиотеке (`.dll/.so/.dylib`)
- Далее: один или несколько входных файлов с исходным кодом
- Последний аргумент: выходная директория

**Результаты работы:**
В выходной директории создаются:
- `tree/<имя_файла>` — логическое дерево разбора
- `graph/<имя_файла>_<имя_функции>.svg` — CFG каждой функции
- `call_graph.svg` — граф вызовов
- `call_graph.errors.txt` — найденные ошибки парсинга (создаётся при наличии ошибок)
- `type_errors.txt` — ошибки типизации (создаётся при наличии ошибок)
- `typed_graph/<имя_файла>_<имя_функции>.svg` — типизированные CFG
- `result.asm` — сгенерированный ассемблерный код (создаётся только при успешной трансляции)

### Шаг 2: Сборка и выполнение
После успешной генерации ассемблерного кода, для его сборки и выполнения используется скрипт `architecture/build.ps1`.

**Важно:** Скрипт `build.ps1` по умолчанию ожидает файл `test.asm` в директории `architecture/`. Необходимо скопировать сгенерированный файл:

```
Copy-Item out\result.asm architecture\test.asm
```

Затем запустить скрипт:

```
@architecture\build.ps1
```

Или можно передать путь к файлу напрямую через параметр:

```
@architecture\build.ps1 -AsmListing "result.asm" -SourcesDir "C:\Users\User\Downloads\parsing_grammar\out\"
```

Скрипт автоматически:
- Собирает ассемблерный код через удалённый сервис
- Скачивает скомпилированный бинарный файл
- Выполняет программу и сохраняет результат в файл, указанный параметром `OutputFile` (по умолчанию `file`)

## Полезное
- Примеры входных файлов — в `examples/`.
- Отчёт по заданию: `report/ЯП_3_лаба_Р4119_Симоновский.pdf`.
